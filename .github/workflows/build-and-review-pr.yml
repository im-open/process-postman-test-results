name: Build and Review PR
run-name: 'Build and Review PR #${{ github.event.pull_request.number }}'

on:
  # https://docs.github.com/en/actions/security-guides/automatic-token-authentication#permissions-for-the-github_token
  #
  # This workflow uses the pull_request trigger which prevents write permissions on the
  # GH_TOKEN and secrets access from public forks.  This should remain as a pull_request
  # trigger to minimize the access public forks have in the repository.  The reduced
  # permissions are adequate but do mean that re-compiles and readme changes will have to be
  # made manually by the PR author.  These auto-updates could be done by this workflow
  # for branches but in order to re-trigger a PR build (which is needed for status checks),
  # we would make the commits with a different user and their PAT.  To minimize exposure
  # and complication we will request those changes be manually made by the PR author.
  pull_request:
    types: [opened, synchronize, reopened]
  # paths:
  #   Do not include specific paths here.  We always want this build to run and produce a
  #   status check which are branch protection rules can use.  If this is skipped because of
  #   path filtering, a status check will not be created and we won't be able to merge the PR
  #   without disabling that requirement.  If we have a status check that is always produced,
  #   we can also use that to require all branches be up to date before they are merged.

env:
  EMPTY_JSON_RESULTS_FILE: './test/input-files/empty.json'
  FAILING_JSON_RESULTS_FILE: './test/input-files/failing.json'
  NO_TESTS_JSON_RESULTS_FILE: './test/input-files/no-tests.json'
  PASSING_JSON_RESULTS_FILE: './test/input-files/passing.json'
  TRUNCATE_JSON_RESULTS_FILE: './test/input-files/truncate.json'

jobs:
  build-and-review-pr:
    # This reusable workflow will check to see if an action's source code has changed based on
    # whether the PR includes files that match the files-with-code arg or are in one of the
    # dirs-with-code directories.  If there are source code changes, this reusable workflow
    # will then run the action's build (if one was provided) and update the README.md with the
    # the latest version of the action.  If those two steps result in any changes that need to
    # be committed, the workflow will fail because the PR needs some updates.  Instructions for
    # updating the PR will be available in the build log, the workflow summary and as a PR
    # comment if the PR came from a branch (not a fork).
    # This workflow assumes:
    #  - The main README.md is at the root of the repo
    #  - The README contains a contribution guidelines and usage examples section
    uses: im-open/.github/.github/workflows/reusable-build-and-review-pr.yml@v1
    with:
      action-name: ${{ github.repository }}
      default-branch: main
      readme-name: 'README.md'

      # The id of the contribution guidelines section of the README.md
      readme-contribution-id: '#contributing'

      # The id of the usage examples section of the README.md
      readme-examples-id: '#usage-examples'

      # The files that contain source code for the action.  Only files that affect the action's execution
      # should be included like action.yml or package.json.  Do not include files like README.md or .gitignore.
      # Files do not need to be explicitly provided here if they fall under one of the dirs in dirs-with-code.
      # ** This value must match the same files-with-code argument specified in increment-version-on-merge.yml.
      files-with-code: 'action.yml,package.json,package-lock.json'

      # The directories that contain source code for the action.  Only dirs with files that affect the action's
      # execution should be included like src or dist.  Do not include dirs like .github or node_modules.
      # ** This value must match the same dirs-with-code argument specified in increment-version-on-merge.yml.
      dirs-with-code: 'src,dist'

      # The npm script to run to build the action.  This is typically 'npm run build' if the
      # action needs to be compiled.  For composite-run-steps actions this is typically empty.
      build-command: 'npm run build'

  unit-tests:
    runs-on: ubuntu-latest
    env:
      PASSING_MD_FILE: './test/expected-markdown/unit-tests/passing-tests.md'
      FAILING_MD_FILE: './test/expected-markdown/unit-tests/failing-tests.md'
      NO_TESTS_MD_FILE: './test/expected-markdown/unit-tests/no-tests.md'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                         TEST 1 - MISSING TOKEN INPUT                                        '
        run: echo ""

      - name: 1 - When process-postman-test-results is called with a missing github-token input
        id: missing-github-token
        if: always()
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: ''
          results-file: '${{ env.EMPTY_JSON_RESULTS_FILE }}'

      - name: 1 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-github-token.outcome }}"

      - name: 1 - And each of the outputs should be empty
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-outcome output" --value "${{ steps.missing-github-token.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-github-token.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-github-token.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-github-token.outputs.status-check-id }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-github-token.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                     TEST 2 - MISSING RESULTS_FILE INPUT                                     '
        run: echo ""

      - name: 2 - When process-postman-test-results is called with a missing results-file input
        id: missing-results-file
        if: always()
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ''

      - name: 2 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.missing-results-file.outcome }}"

      - name: 2 - And each of the outputs should be empty
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-outcome output" --value "${{ steps.missing-results-file.outputs.test-outcome }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.missing-results-file.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.missing-results-file.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.missing-results-file.outputs.status-check-id }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.missing-results-file.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                     TEST 3 - RESULTS_FILE DOES NOT EXIST                                    '
        run: echo ""

      - name: 3 - When process-postman-test-results is called with a results file that does not exist
        id: file-does-not-exist
        if: always()
        continue-on-error: true # This is needed because we expect the step to fail but we need it to "pass" in order for the test job to succeed.
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: './test/input-files/file-that-does-not-exist.json'
          create-status-check: false
          create-pr-comment: false

      - name: 3 - Then the action outcome should be failure
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "failure" --actual "${{ steps.file-does-not-exist.outcome }}"

      - name: 3 - And the 'test-outcome' output should be Failed
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected 'Failed' --actual "${{ steps.file-does-not-exist.outputs.test-outcome }}"

      - name: 3 - And the remaining outputs should be empty
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.file-does-not-exist.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.file-does-not-exist.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.file-does-not-exist.outputs.status-check-id }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.file-does-not-exist.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                       TEST 4 - RESULTS_FILE IS EMPTY                                        '
        run: echo ""

      - name: 4 - When process-postman-test-results is called with a results file that is empty
        id: empty-file
        if: always()
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: '${{ env.EMPTY_JSON_RESULTS_FILE }}'
          create-status-check: false
          create-pr-comment: false

      - name: 4 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.empty-file.outcome }}"

      - name: 4 - And the 'test-outcome' output should be Failed
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected 'Failed' --actual "${{ steps.empty-file.outputs.test-outcome }}"

      - name: 4 - And the remaining outputs should be empty
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.empty-file.outputs.test-results-truncated }}"
          ./test/assert-value-is-empty.sh --name "test-results-file-path output" --value "${{ steps.empty-file.outputs.test-results-file-path }}"
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.empty-file.outputs.status-check-id }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.empty-file.outputs.pr-comment-id }}"

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                           TEST 5 - PASSING TESTS                                            '
        run: echo ""

      - name: 5 - When process-postman-test-results is called with a results file that has all passing tests
        id: passing-tests
        if: always()
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: '${{ env.PASSING_JSON_RESULTS_FILE }}'
          create-status-check: false
          create-pr-comment: false
          timezone: 'America/Denver'
          report-name: 'Passing Test Results'

      - name: 5 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.passing-tests.outcome }}"

      - name: 5 - And the 'test-outcome' output should be Passed
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected 'Passed' --actual "${{ steps.passing-tests.outputs.test-outcome }}"

      - name: 5 - And the 'test-results-file-path output' should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.passing-tests.outputs.test-results-file-path }}"

      - name: 5 - And the remaining outputs should be empty since status checks and pr comments were not created
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.passing-tests.outputs.status-check-id }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.passing-tests.outputs.pr-comment-id }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.passing-tests.outputs.test-results-truncated }}"

      - name: 5 - And the contents of test-results.md file should match the contents of ${{ env.PASSING_MD_FILE }} file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The provided timezone (MST/MDT) is used
          #  - The provided report name is used
          #  - The badge has the right count/status/color
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report

          expectedFileName="${{ env.PASSING_MD_FILE }}"
          actualFileName="${{ steps.passing-tests.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                           TEST 6 - FAILING TESTS                                            '
        run: echo ""

      - name: 6 - When process-postman-test-results is called with a results file that has failing tests
        id: failing-tests
        if: always()
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: '${{ env.FAILING_JSON_RESULTS_FILE }}'
          create-status-check: false
          create-pr-comment: false
          # timezone: 'UTC'  # Test the default
          # report-name: 'Postman Test Results'  # Test the default

      - name: 6 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.failing-tests.outcome }}"

      - name: 6 - And the 'test-outcome' output should be Failed
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected 'Failed' --actual "${{ steps.failing-tests.outputs.test-outcome }}"

      - name: 6 - And the 'test-results-file-path output' should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.failing-tests.outputs.test-results-file-path }}"

      - name: 6 - And the remaining outputs should be empty since status checks and pr comments were not created
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.failing-tests.outputs.status-check-id }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.failing-tests.outputs.pr-comment-id }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.failing-tests.outputs.test-results-truncated }}"

      - name: 6 - And the contents of test-results.md file should match the contents of ${{ env.FAILING_MD_FILE }} file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The default timezone (UTC) is used
          #  - The default report name (Postman Test Results) is used
          #  - The badge has the right count/status/color
          #  - The Duration stats are included in the report
          #  - The Counter stats are included in the report
          #  - The failing test details are included in the report

          expectedFileName="${{ env.FAILING_MD_FILE }}"
          actualFileName="${{ steps.failing-tests.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                         TEST 7 - NO TESTS REPORTED                                          '
        run: echo ""

      - name: 7 - When process-postman-test-results is called with a results file that has no tests reported
        id: no-tests
        if: always()
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: '${{ env.NO_TESTS_JSON_RESULTS_FILE }}'
          report-name: 'Missing Test Results'
          create-status-check: false
          create-pr-comment: false

      - name: 7 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-tests.outcome }}"

      - name: 7 - And the 'test-outcome' output should be Passed
        if: always()
        run: |
          ./test/assert-values-match.sh --name "test-outcome output" --expected 'Passed' --actual "${{ steps.no-tests.outputs.test-outcome }}"

      - name: 7 - And the 'test-results-file-path output' should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "test-results-file-path output" --value "${{ steps.no-tests.outputs.test-results-file-path }}"

      - name: 7 - And the remaining outputs should be empty since status checks and pr comments were not created
        if: always()
        run: |
          ./test/assert-value-is-empty.sh --name "status-check-id output" --value "${{ steps.no-tests.outputs.status-check-id }}"
          ./test/assert-value-is-empty.sh --name "pr-comment-id output" --value "${{ steps.no-tests.outputs.pr-comment-id }}"
          ./test/assert-value-is-empty.sh --name "test-results-truncated output" --value "${{ steps.no-tests.outputs.test-results-truncated }}"

      - name: 7 - And the contents of test-results.md file should match the contents of ${{ env.NO_TESTS_MD_FILE }} file
        if: always()
        run: |
          # Comparing the test-results.md file will ensure that:
          #  - The default timezone (UTC) is used
          #  - The default report name (Missing Test Results) is used
          #  - The badge has the right count/status/color
          #  - The Duration section should not be included in the report
          #  - The Counter stats are included in the report
          #  - The no-test details are included in the report

          expectedFileName="${{ env.NO_TESTS_MD_FILE }}"
          actualFileName="${{ steps.no-tests.outputs.test-results-file-path }}"
          ./test/assert-file-contents-match.sh --expectedFileName $expectedFileName --actualFileName $actualFileName

  test-status-checks:
    runs-on: ubuntu-latest
    env:
      NO_FAILURES_MD_FILE: './test/expected-markdown/status-checks/no-failures.md'
      IGNORE_FAILURES_MD_FILE: './test/expected-markdown/status-checks/ignore-failures.md'
      ALLOW_FAILURES_MD_FILE: './test/expected-markdown/status-checks/allow-failures.md'

      NO_FAILURES_REPORT_NAME: 'No Failures Scenario'
      IGNORE_FAILURES_REPORT_NAME: 'Ignore Failures Scenario'
      ALLOW_FAILURES_REPORT_NAME: 'Allow Failures Scenario'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires the `checks: write` scope on the GITHUB_TOKEN which PRs from forks do not have.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                     TEST 8 - STATUS CHECK - NO FAILURES                                    '
        run: echo ""

      - name: 8 - When process-postman-test-results is called with no failures
        if: always()
        id: no-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ${{ env.PASSING_JSON_RESULTS_FILE }}
          report-name: ${{ env.NO_FAILURES_REPORT_NAME }}
          create-status-check: true
          create-pr-comment: false

      - name: 8 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.no-failures.outcome }}"

      - name: 8 - And the status-check-id output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-id output" --value "${{ steps.no-failures.outputs.status-check-id }}"

      - name: 8 - And the test-outcome output should be Passed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Passed" --actual "${{ steps.no-failures.outputs.test-outcome }}"

      - name: 8 - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertStatusCheckExists = require('./test/assert-status-check-exists.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkId = '${{ steps.no-failures.outputs.status-check-id }}';
            const actualCheck = await assertStatusCheckExists(github, context, core, checkId);
            const expectedBody = fs.readFileSync('${{ env.NO_FAILURES_MD_FILE }}', 'utf8');

            const expectedValues = {
              name: 'status check - ${{ env.NO_FAILURES_REPORT_NAME }}'.toLowerCase(),
              status: 'completed',
              conclusion: 'success',
              title: '${{ env.NO_FAILURES_REPORT_NAME }}',
              text: expectedBody
            };
            assertStatusCheckMatchesExpectations(core, actualCheck, expectedValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                   TEST 9 - STATUS CHECK - IGNORE FAILURES                                  '
        run: echo ""

      - name: 9 - When process-postman-test-results is called with test failures & ignore-test-failures=true
        if: always()
        id: ignore-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ${{ env.FAILING_JSON_RESULTS_FILE }}
          report-name: ${{ env.IGNORE_FAILURES_REPORT_NAME }}
          create-status-check: true
          ignore-test-failures: true
          create-pr-comment: false

      - name: 9 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.ignore-failures.outcome }}"

      - name: 9 - And the status-check-id output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-id output" --value "${{ steps.ignore-failures.outputs.status-check-id }}"

      - name: 9 - And the test-outcome output should be Failed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.ignore-failures.outputs.test-outcome }}"

      - name: 9 - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertStatusCheckExists = require('./test/assert-status-check-exists.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkId = '${{ steps.ignore-failures.outputs.status-check-id }}';
            const actualCheck = await assertStatusCheckExists(github, context, core, checkId);
            const expectedBody = fs.readFileSync('${{ env.IGNORE_FAILURES_MD_FILE }}', 'utf8');

            const expectedValues = {
              name: 'status check - ${{ env.IGNORE_FAILURES_REPORT_NAME }}'.toLowerCase(),
              status: 'completed',
              conclusion: 'neutral',
              title: '${{ env.IGNORE_FAILURES_REPORT_NAME }}',
              text: expectedBody
            };
            assertStatusCheckMatchesExpectations(core, actualCheck, expectedValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                    TEST 10 - STATUS CHECK - ALLOW FAILURES                                    '
        run: echo ""

      - name: 10 - When process-postman-test-results is called with test failures & ignore-test-failures=false
        if: always()
        id: allow-failures
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ${{ env.FAILING_JSON_RESULTS_FILE }}
          report-name: ${{ env.ALLOW_FAILURES_REPORT_NAME }}
          create-status-check: true
          ignore-test-failures: false
          create-pr-comment: false

      - name: 10 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.allow-failures.outcome }}"

      - name: 10 - And the status-check-id output should be populated
        if: always()
        run: ./test/assert-value-is-not-empty.sh --name "status-check-id output" --value "${{ steps.allow-failures.outputs.status-check-id }}"

      - name: 10 - And the test-outcome output should be Failed
        if: always()
        run: ./test/assert-values-match.sh --name "test-outcome output" --expected "Failed" --actual "${{ steps.allow-failures.outputs.test-outcome }}"

      - name: 10 - And the status check should match the inputs
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertStatusCheckExists = require('./test/assert-status-check-exists.js');
            const assertStatusCheckMatchesExpectations = require('./test/assert-status-check-matches-expectations.js');

            const checkId = '${{ steps.allow-failures.outputs.status-check-id }}';
            const actualCheck = await assertStatusCheckExists(github, context, core, checkId);
            const expectedBody = fs.readFileSync('${{ env.ALLOW_FAILURES_MD_FILE }}', 'utf8');

            const expectedValues = {
              name: 'status check - ${{ env.ALLOW_FAILURES_REPORT_NAME }}'.toLowerCase(),
              status: 'completed',
              conclusion: 'failure',
              title: '${{ env.ALLOW_FAILURES_REPORT_NAME }}',
              text: expectedBody
            };
            assertStatusCheckMatchesExpectations(core, actualCheck, expectedValues);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                   TEARDOWN                                                  '
        run: echo ""

      - name: Teardown - Modify failing Status Check conclusion
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const updateFailingStatusCheck = require('./test/update-failing-status-check.js');

            await updateFailingStatusCheck(github, context, core, '${{ steps.allow-failures.outputs.status-check-id }}');

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""

  test-pr-comments:
    runs-on: ubuntu-latest
    env:
      EXISTING_COMMENT_ID: ''
      COMMENT_IDENTIFIER: 'existing-comment-${{ github.run_id }}'

      UPDATE_WITH_MATCHING_PREFIX_MD_FILE: './test/expected-markdown/pr-comments/update-matching-prefix.md'
      UPDATE_WITHOUT_MATCHING_PREFIX_MD_FILE: './test/expected-markdown/pr-comments/update-without-matching-prefix.md'
      NO_UPDATE_MD_FILE: './test/expected-markdown/pr-comments/no-update.md'
      TRUNCATE_FULL_MD_FILE: './test/expected-markdown/pr-comments/truncate-full-markdown.md'
      TRUNCATE_TRUNCATED_MD_FILE: './test/expected-markdown/pr-comments/truncate-truncated-markdown.md'

      UPDATE_WITH_MATCHING_PREFIX_REPORT_NAME: 'Update Comment with Matching Prefix Scenario'
      UPDATE_WITHOUT_MATCHING_PREFIX_REPORT_NAME: 'Update Comment but no Matching Prefix Scenario'
      NO_UPDATE_REPORT_NAME: 'Do Not Update Comment Scenario'
      TRUNCATE_FAILURES_REPORT_NAME: 'Truncated PR Comment Scenario'

    steps:
      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                    SETUP                                                    '
        run: echo ""

      - name: Setup - Fail test job if fork
        run: |
          if [ "${{ github.event.pull_request.head.repo.fork }}" == "true" ]; then
            echo "This test job requires the `pull_request: write` scope on the GITHUB_TOKEN which PRs from forks do not have.  Before this PR can be merged, the tests should be run on an intermediate branch created by repository owners."
            exit 1
          fi

      - name: Setup - Checkout the action
        uses: actions/checkout@v4

      - name: Setup - Delete pre-existing process-postman-test-results PR Comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const deletePrComments = require('./test/delete-pre-existing-comments.js');
            await deletePrComments(github, context, core);

      - name: Setup - Create a process-postman-test-results comment that can be updated
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `<!-- im-open/process-postman-test-results ${{ env.COMMENT_IDENTIFIER }} -->\nThis comment will be replaced soon.`
            })
            .then(response => {
              core.info(`The 'existing' process-postman-test-results comment has id: ${response.data.id}`);
              core.exportVariable('EXISTING_COMMENT_ID', response.data.id);
            })
            .catch(error => {
              core.setFailed(`An error occurred in the setup step while creating a comment: ${error.message}`);
            });
            await new Promise(r => setTimeout(r, 5 * 1000));

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                              TEST 11 - PR COMMENT - UPDATE W/ MATCHING PREFIX                               '
        run: echo ""

      - name: 11 - When process-postman-test-results is called with updateComment=true and there is a comment with matching prefix
        if: always()
        id: update-with-matching-prefix
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ${{ env.PASSING_JSON_RESULTS_FILE }}
          report-name: ${{ env.UPDATE_WITH_MATCHING_PREFIX_REPORT_NAME }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: ${{ env.COMMENT_IDENTIFIER }}

      - name: 11 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.update-with-matching-prefix.outcome }}"

      - name: 11 - And the pr-comment-id output should match the existing comment id
        if: always()
        run: ./test/assert-values-match.sh --name "pr-comment-id output" --expected "${{ env.EXISTING_COMMENT_ID }}" --actual "${{ steps.update-with-matching-prefix.outputs.pr-comment-id }}"

      - name: 11 - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.update-with-matching-prefix.outputs.test-results-truncated }}"

      - name: 11 - And the pr-comment should match the match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.update-with-matching-prefix.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.UPDATE_WITH_MATCHING_PREFIX_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.update-with-matching-prefix.outputs.test-results-file-path }}', 'utf8');

            const expectedComment = {
              prefix: '<!-- im-open/process-postman-test-results ${{ env.COMMENT_IDENTIFIER }} -->',
              fullMarkdown: expectedMarkdown,
              action: 'updated',
              truncated: false
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                              TEST 12 - PR COMMENT - UPDATE W/O MATCHING PREFIX                              '
        run: echo ""

      - name: 12 - When process-postman-test-results is called with updateComment=true but there is no comment with matching prefix
        if: always()
        id: update-without-matching-prefix
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ${{ env.PASSING_JSON_RESULTS_FILE }}
          report-name: ${{ env.UPDATE_WITHOUT_MATCHING_PREFIX_REPORT_NAME }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: 'different-identifier-${{ github.run_id }}'

      - name: 12 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.update-without-matching-prefix.outcome }}"

      - name: 12 - And the pr-comment-id output should be different than the existing comment id
        if: always()
        run: ./test/assert-values-do-not-match.sh --name "pr-comment-id output" --value1 "${{ env.EXISTING_COMMENT_ID }}" --value2 "${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}"

      - name: 12 - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.update-without-matching-prefix.outputs.test-results-truncated }}"

      - name: 12 - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.UPDATE_WITHOUT_MATCHING_PREFIX_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.update-without-matching-prefix.outputs.test-results-file-path }}', 'utf8');

            const expectedComment = {
              prefix: '<!-- im-open/process-postman-test-results different-identifier-${{ github.run_id }} -->',
              fullMarkdown: expectedMarkdown,
              action: 'created',
              truncated: false
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                       TEST 13 - PR COMMENT - NO UPDATE                                      '
        run: echo ""

      - name: 13 - When process-postman-test-results is called with updateComment=false
        if: always()
        id: matching-prefix-no-update
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ${{ env.PASSING_JSON_RESULTS_FILE }}
          report-name: ${{ env.NO_UPDATE_REPORT_NAME }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: false

      - name: 13 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.matching-prefix-no-update.outcome }}"

      - name: 13 - And the pr-comment-id output should be different than the existing comment id
        if: always()
        run: ./test/assert-values-do-not-match.sh --name "pr-comment-id output" --value1 "${{ env.EXISTING_COMMENT_ID }}" --value2 "${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}"

      - name: 13 - And the test-results-truncated output should be false
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "false" --actual "${{ steps.matching-prefix-no-update.outputs.test-results-truncated }}"

      - name: 13 - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.NO_UPDATE_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.matching-prefix-no-update.outputs.test-results-file-path }}', 'utf8');

            const expectedComment = {
              prefix: `<!-- im-open/process-postman-test-results test-pr-comments_matching-prefix-no-update -->`,
              fullMarkdown: expectedMarkdown,
              action: 'created',
              truncated: false
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                       TEST 14 - PR COMMENT - TRUNCATE                                       '
        run: echo ""

      - name: 14 - When process-postman-test-results is called with a large comment that needs to be truncated
        if: always()
        id: truncate
        uses: ./
        with:
          github-token: '${{ secrets.GITHUB_TOKEN }}'
          results-file: ${{ env.TRUNCATE_JSON_RESULTS_FILE }}
          report-name: ${{ env.TRUNCATE_FAILURES_REPORT_NAME }}
          create-status-check: false
          create-pr-comment: true
          update-comment-if-one-exists: true
          comment-identifier: ${{ env.COMMENT_IDENTIFIER }}

      - name: 14 - Then the action outcome should be success
        if: always()
        run: ./test/assert-values-match.sh --name "step outcome" --expected "success" --actual "${{ steps.truncate.outcome }}"

      - name: 14 - And the pr-comment-id output should match the existing comment id
        if: always()
        run: ./test/assert-values-match.sh --name "pr-comment-id output" --expected "${{ env.EXISTING_COMMENT_ID }}" --actual "${{ steps.truncate.outputs.pr-comment-id }}"

      - name: 14 - And the test-results-truncated output should be true
        if: always()
        run: ./test/assert-values-match.sh --name "test-results-truncated output" --expected "true" --actual "${{ steps.truncate.outputs.test-results-truncated }}"

      - name: 14 - And the pr-comment should match the expected values
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const assertCommentExists = require('./test/assert-pr-comment-exists.js');
            const assertCommentMatchesExpectations = require('./test/assert-pr-comment-matches-expectations.js');

            const commentId = '${{ steps.truncate.outputs.pr-comment-id }}';
            const actualComment = await assertCommentExists(github, context, core, commentId);

            const expectedMarkdown = fs.readFileSync('${{ env.TRUNCATE_FULL_MD_FILE }}', 'utf8');
            const expectedTruncatedMarkdown = fs.readFileSync('${{ env.TRUNCATE_TRUNCATED_MD_FILE }}', 'utf8');
            const actualTestResults = fs.readFileSync('${{ steps.truncate.outputs.test-results-file-path }}', 'utf8');
            const truncateMessage = 'Test results truncated due to character limit. See full report in output.';

            const expectedComment = {
              prefix: `<!-- im-open/process-postman-test-results ${{ env.COMMENT_IDENTIFIER }} -->`,
              fullMarkdown: expectedMarkdown,
              action: 'updated',
              truncated: true,
              truncatedMarkdown: expectedTruncatedMarkdown,
            };
            assertCommentMatchesExpectations(core, actualComment, actualTestResults, expectedComment);

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
      - name: '                                                   TEARDOWN                                                  '
        run: echo ""

      - name: Teardown - Delete PR Comments
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const deletePrComment = require('./test/delete-pr-comment.js');

            await deletePrComment(github, context, core, '${{ env.EXISTING_COMMENT_ID }}');
            await deletePrComment(github, context, core, '${{ steps.matching-prefix-no-update.outputs.pr-comment-id }}');
            await deletePrComment(github, context, core, '${{ steps.update-without-matching-prefix.outputs.pr-comment-id }}');

      - name: '-------------------------------------------------------------------------------------------------------------'
        run: echo ""
